/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _canvas = __webpack_require__(1);

	var _canvas2 = _interopRequireDefault(_canvas);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(function () {

	  var el = document.getElementById('canvas-holder');
	  var holder = el.closest('.canvas-wrapper');

	  (0, _canvas2.default)(el, holder);
	})();

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _throttle = __webpack_require__(2);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _circle = __webpack_require__(3);

	var _circle2 = _interopRequireDefault(_circle);

	var _Parallelogram = __webpack_require__(5);

	var _Parallelogram2 = _interopRequireDefault(_Parallelogram);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Canvas = function Canvas(el, holder) {
	  var gl = el.getContext("2d");
	  var circles = [];
	  var enableDragAndDrop = false;
	  var resetBtn;

	  var onResize = function onResize() {
	    el.width = holder.offsetWidth;
	    gl = el.getContext("2d");
	    circles = [];
	    enableDragAndDrop = false;
	  };

	  var onClick = function onClick(e) {
	    drawCircles(e);

	    if (circles.length === 3) drawParallelogram();
	  };

	  var drawParallelogram = function drawParallelogram() {
	    var myParallelogram = (0, _Parallelogram2.default)(circles[0], circles[1], circles[2], '#0033cc', gl);
	    var lastPoint = myParallelogram.draw();

	    (0, _circle2.default)(lastPoint, 1, gl, '#ff0000').draw();

	    myParallelogram.drawLines();
	    var centerPoint = myParallelogram.calculateCenter();
	    var paralelogramArea = myParallelogram.calculateArea();

	    (0, _circle2.default)(centerPoint, null, gl, '#ffcc00').drawBasedOnArea(paralelogramArea);
	  };

	  var resetCanvas = function resetCanvas(e) {
	    e.preventDefault();

	    gl = el.getContext("2d");
	    circles = [];
	    enableDragAndDrop = false;
	  };

	  var drawCircles = function drawCircles(e) {

	    if (circles.length < 3) {
	      (0, _circle2.default)([e.offsetX, e.offsetY], 11, gl, '#ff0000').draw();
	      circles.push([e.offsetX, e.offsetY]);
	    } else {
	      enableDragAndDrop = true;
	    }
	  };

	  var initElement = function initElement() {
	    resetBtn = document.querySelector('a.reset');
	    el.height = 800;
	    el.width = holder.offsetWidth;
	    resetBtn.addEventListener('click', resetCanvas);
	    window.addEventListener('resize', (0, _throttle2.default)(onResize, 100));
	    el.addEventListener('click', onClick);
	  };

	  initElement();

	  return {};
	};

	exports.default = Canvas;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var throttle = function throttle(fn, wait) {
	  var time = Date.now();
	  return function () {
	    if (time + wait - Date.now() < 0) {
	      fn();
	      time = Date.now();
	    }
	  };
	};

	exports.default = throttle;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shape = __webpack_require__(4);

	var _shape2 = _interopRequireDefault(_shape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Circle = function Circle(_coordinates, _radius, gl, color) {
	  var coordinates = _coordinates;
	  var radius = _radius;

	  var draw = function draw() {
	    gl.beginPath();
	    gl.arc(_coordinates[0], _coordinates[1], _radius, 0, 2 * Math.PI);
	    this.setLineColor(color, gl);
	    gl.stroke();
	  };

	  var drawBasedOnArea = function drawBasedOnArea(area) {
	    gl.beginPath();
	    _radius = Math.round(Math.sqrt(area / Math.PI));

	    gl.arc(_coordinates[0], _coordinates[1], _radius, 0, 2 * Math.PI);
	    this.setLineColor(color, gl);
	    gl.stroke();
	  };

	  var factory = Object.create((0, _shape2.default)());
	  factory.draw = draw;
	  factory.drawBasedOnArea = drawBasedOnArea;

	  return factory;
	};

	exports.default = Circle;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Shape = function Shape() {
	  var lineColor;

	  var validateHexa = function validateHexa(inputString) {
	    var re = /[0-9A-Fa-f]{6}/g;
	    if (re.test(inputString)) {
	      return true;
	    } else {
	      return false;
	    }
	  };

	  var setLineColor = function setLineColor(color, gl) {
	    if (validateHexa(color)) {
	      gl.strokeStyle = color;
	    } else console.log('the color came empty');
	  };

	  return {
	    lineColor: null,
	    setLineColor: setLineColor
	  };
	};

	exports.default = Shape;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shape = __webpack_require__(4);

	var _shape2 = _interopRequireDefault(_shape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Parallelogram = function Parallelogram(_pointA, _pointB, _pointC, color, gl) {
	  var pointA = _pointA;
	  var pointB = _pointB;
	  var pointC = _pointC;
	  var pointD;
	  var centerPoint;
	  var area;

	  var calculatePointD = function calculatePointD() {
	    var _AB;

	    //pointD = C + BA
	    _AB = [pointA[0] - pointB[0], pointA[1] - pointB[1]];

	    pointD = [pointC[0] + _AB[0], pointC[1] + _AB[1]];
	  };

	  var calculateCenter = function calculateCenter() {

	    if (pointD) {
	      //M = A + 1/2 (AC)

	      var _midAC = [1 / 2 * (pointC[0] - pointA[0]), 1 / 2 * (pointC[1] - pointA[1])];
	      centerPoint = [Math.round(pointA[0] + _midAC[0]), Math.round(pointA[1] + _midAC[1])];

	      return centerPoint;
	    } else {
	      console.log('pointD is required');
	      return null;
	    }
	  };

	  var calculateArea = function calculateArea() {
	    if (pointD) {
	      //since we dont have h 
	      //the parallelogram is can be devided in two triengles and calculate the area of each triangle 
	      //the area will be calculated based in the semiperimeter formula https://en.wikipedia.org/wiki/Semiperimeter 

	      //triangle distances A B C
	      var _AB = calculateDistanceBetweenPoints(pointA[0], pointA[1], pointB[0], pointB[1]);
	      var _BC = calculateDistanceBetweenPoints(pointB[0], pointB[1], pointC[0], pointC[1]);
	      var _AC = calculateDistanceBetweenPoints(pointA[0], pointA[1], pointC[0], pointC[1]);

	      var s = (_AB + _BC + _AC) / 2;
	      area = Math.sqrt(s * (s - _AB) * (s - _BC) * (s - _AC));

	      return area * 2;
	    } else {
	      console.log('pointD is required');
	      return null;
	    }
	  };

	  var calculateDistanceBetweenPoints = function calculateDistanceBetweenPoints(XO, YO, X1, Y1) {
	    var distance = Math.sqrt(Math.pow(X1 - XO, 2) + Math.pow(Y1 - YO, 2));
	    return distance;
	  };

	  var drawLines = function drawLines() {
	    this.setLineColor(color, gl);

	    gl.moveTo(pointA[0], pointA[1]);
	    gl.lineTo(pointB[0], pointB[1]);
	    gl.stroke();

	    gl.moveTo(pointB[0], pointB[1]);
	    gl.lineTo(pointC[0], pointC[1]);
	    gl.stroke();

	    gl.moveTo(pointC[0], pointC[1]);
	    gl.lineTo(pointD[0], pointD[1]);
	    gl.stroke();

	    gl.moveTo(pointD[0], pointD[1]);
	    gl.lineTo(pointA[0], pointA[1]);
	    gl.stroke();
	  };

	  var draw = function draw() {
	    calculatePointD();

	    return pointD;
	  };

	  var factory = Object.create((0, _shape2.default)());
	  factory.draw = draw;
	  factory.drawLines = drawLines;
	  factory.calculateCenter = calculateCenter;
	  factory.calculateArea = calculateArea;

	  return factory;
	};

	exports.default = Parallelogram;

/***/ })
/******/ ]);