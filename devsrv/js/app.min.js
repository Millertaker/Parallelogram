/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _canvas = __webpack_require__(1);

	var _canvas2 = _interopRequireDefault(_canvas);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(function () {

	  var el = document.getElementById('canvas-holder');
	  var holder = el.closest('.canvas-wrapper');

	  (0, _canvas2.default)(el, holder);
	})();

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _throttle = __webpack_require__(2);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _circle = __webpack_require__(3);

	var _circle2 = _interopRequireDefault(_circle);

	var _Parallelogram = __webpack_require__(5);

	var _Parallelogram2 = _interopRequireDefault(_Parallelogram);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Canvas = function Canvas(el, holder) {
	  var gl = el.getContext("2d");
	  var circles = [];
	  var circlesRadius = 11;
	  var enableDragAndDrop = false;
	  var isDragging = false;
	  var resetBtn;
	  var draggedCircle;

	  var onResize = function onResize() {
	    el.width = holder.offsetWidth;
	    gl = el.getContext("2d");
	    circles = [];
	    enableDragAndDrop = false;
	  };

	  var onClick = function onClick(e) {
	    if (!isDragging) {
	      drawCircles(e);

	      if (circles.length === 3) drawParallelogram();
	    }
	  };

	  var drawParallelogram = function drawParallelogram() {
	    var myParallelogram = (0, _Parallelogram2.default)(circles[0], circles[1], circles[2], '#0033cc', gl);
	    var lastPoint = myParallelogram.draw();

	    (0, _circle2.default)(lastPoint, 1, gl, '#ff0000').draw();

	    myParallelogram.drawLines();
	    var centerPoint = myParallelogram.calculateCenter();
	    var paralelogramArea = myParallelogram.calculateArea();

	    (0, _circle2.default)(centerPoint, null, gl, '#ffcc00').drawBasedOnArea(paralelogramArea);
	  };

	  var onMouseDown = function onMouseDown(e) {
	    e.preventDefault();

	    if (enableDragAndDrop) {
	      isDragging = isCircleClicked(e.offsetX, e.offsetY);;
	    }
	  };

	  var isCircleClicked = function isCircleClicked(xcoor, ycoor) {
	    for (var c in circles) {
	      if (pointInCircle(xcoor, ycoor, circles[c][0], circles[c][1], circlesRadius)) {
	        draggedCircle = c;

	        return true;
	      }
	    }
	  };

	  var pointInCircle = function pointInCircle(x, y, cx, cy, radius) {
	    var distancesquared = (x - cx) * (x - cx) + (y - cy) * (y - cy);
	    return distancesquared <= radius * radius;
	  };

	  var onMouseUp = function onMouseUp(e) {
	    e.preventDefault();

	    if (enableDragAndDrop) {
	      isDragging = false;
	    }
	  };

	  var onMouseMove = function onMouseMove(e) {
	    e.preventDefault();

	    if (isDragging) {
	      circles[draggedCircle] = [e.offsetX, e.offsetY];
	      reDraw();
	    }
	  };

	  var resetCanvas = function resetCanvas(e) {
	    e.preventDefault();

	    circles = [];
	    enableDragAndDrop = false;

	    gl.clearRect(0, 0, el.width, el.height);
	  };

	  var drawCircles = function drawCircles(e) {

	    if (circles.length < 3) {
	      (0, _circle2.default)([e.offsetX, e.offsetY], circlesRadius, gl, '#ff0000').draw();
	      circles.push([e.offsetX, e.offsetY]);
	    }

	    if (circles.length === 3) {
	      enableDragAndDrop = true;
	    }
	  };

	  var reDraw = function reDraw() {
	    gl.clearRect(0, 0, el.width, el.height);
	    for (var i in circles) {
	      (0, _circle2.default)([circles[i][0], circles[i][1]], circlesRadius, gl, '#ff0000').draw();
	    }
	    drawParallelogram();
	  };

	  var initElement = function initElement() {
	    resetBtn = document.querySelector('a.reset');
	    el.height = 800;
	    el.width = holder.offsetWidth;
	    el.addEventListener('mousedown', onMouseDown);
	    el.addEventListener('mousemove', onMouseMove);
	    el.addEventListener('mouseup', onMouseUp);
	    resetBtn.addEventListener('click', resetCanvas);
	    window.addEventListener('resize', (0, _throttle2.default)(onResize, 100));
	    el.addEventListener('click', onClick);
	  };

	  initElement();

	  return {};
	};

	exports.default = Canvas;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var throttle = function throttle(fn, wait) {
	  var time = Date.now();
	  return function () {
	    if (time + wait - Date.now() < 0) {
	      fn();
	      time = Date.now();
	    }
	  };
	};

	exports.default = throttle;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shape = __webpack_require__(4);

	var _shape2 = _interopRequireDefault(_shape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Circle = function Circle(_coordinates, _radius, gl, color) {
	  var coordinates = _coordinates;
	  var radius = _radius;

	  var draw = function draw() {
	    gl.beginPath();
	    gl.arc(_coordinates[0], _coordinates[1], _radius, 0, 2 * Math.PI);
	    this.setLineColor(color, gl);
	    gl.stroke();
	  };

	  var drawBasedOnArea = function drawBasedOnArea(area) {
	    gl.beginPath();
	    _radius = Math.round(Math.sqrt(area / Math.PI));

	    gl.arc(_coordinates[0], _coordinates[1], _radius, 0, 2 * Math.PI);
	    this.setLineColor(color, gl);
	    gl.stroke();
	  };

	  var factory = Object.create((0, _shape2.default)());
	  factory.draw = draw;
	  factory.drawBasedOnArea = drawBasedOnArea;

	  return factory;
	};

	exports.default = Circle;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Shape = function Shape() {
	  var lineColor = null;

	  var validateHexa = function validateHexa(inputString) {
	    var re = /[0-9A-Fa-f]{6}/g;
	    if (re.test(inputString)) {
	      return true;
	    } else {
	      return false;
	    }
	  };

	  var setLineColor = function setLineColor(color, gl) {
	    if (validateHexa(color)) {
	      this.lineColor = color;
	      gl.strokeStyle = color;
	    } else console.log('Message: the color came with an invalid value');
	  };

	  return {
	    lineColor: lineColor,
	    setLineColor: setLineColor
	  };
	};

	exports.default = Shape;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shape = __webpack_require__(4);

	var _shape2 = _interopRequireDefault(_shape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Parallelogram = function Parallelogram(_pointA, _pointB, _pointC, color, gl) {
	  var pointA = _pointA;
	  var pointB = _pointB;
	  var pointC = _pointC;
	  var pointD;
	  var centerPoint;
	  var area;

	  var calculatePointD = function calculatePointD() {
	    var _AB;

	    //pointD = C + BA
	    _AB = [pointA[0] - pointB[0], pointA[1] - pointB[1]];

	    pointD = [pointC[0] + _AB[0], pointC[1] + _AB[1]];
	  };

	  var calculateCenter = function calculateCenter() {

	    if (pointD) {
	      //M = A + 1/2 (AC)

	      var _midAC = [1 / 2 * (pointC[0] - pointA[0]), 1 / 2 * (pointC[1] - pointA[1])];
	      centerPoint = [Math.round(pointA[0] + _midAC[0]), Math.round(pointA[1] + _midAC[1])];

	      return centerPoint;
	    } else {
	      console.log('pointD is required');
	      return null;
	    }
	  };

	  var calculateArea = function calculateArea() {
	    if (pointD) {
	      //since we dont have h 
	      //the parallelogram is can be devided in two triengles and calculate the area of each triangle 
	      //the area will be calculated based in the semiperimeter formula https://en.wikipedia.org/wiki/Semiperimeter 

	      //triangle distances A B C
	      var _AB = calculateDistanceBetweenPoints(pointA[0], pointA[1], pointB[0], pointB[1]);
	      var _BC = calculateDistanceBetweenPoints(pointB[0], pointB[1], pointC[0], pointC[1]);
	      var _AC = calculateDistanceBetweenPoints(pointA[0], pointA[1], pointC[0], pointC[1]);

	      var s = (_AB + _BC + _AC) / 2;
	      area = Math.sqrt(s * (s - _AB) * (s - _BC) * (s - _AC));

	      return area * 2;
	    } else {
	      console.log('pointD is required');
	      return null;
	    }
	  };

	  var calculateDistanceBetweenPoints = function calculateDistanceBetweenPoints(XO, YO, X1, Y1) {
	    var distance = Math.sqrt(Math.pow(X1 - XO, 2) + Math.pow(Y1 - YO, 2));
	    return distance;
	  };

	  var drawLines = function drawLines() {
	    this.setLineColor(color, gl);

	    gl.moveTo(pointA[0], pointA[1]);
	    gl.lineTo(pointB[0], pointB[1]);
	    gl.stroke();

	    gl.moveTo(pointB[0], pointB[1]);
	    gl.lineTo(pointC[0], pointC[1]);
	    gl.stroke();

	    gl.moveTo(pointC[0], pointC[1]);
	    gl.lineTo(pointD[0], pointD[1]);
	    gl.stroke();

	    gl.moveTo(pointD[0], pointD[1]);
	    gl.lineTo(pointA[0], pointA[1]);
	    gl.stroke();
	  };

	  var draw = function draw() {
	    calculatePointD();

	    return pointD;
	  };

	  var factory = Object.create((0, _shape2.default)());
	  factory.draw = draw;
	  factory.drawLines = drawLines;
	  factory.calculateCenter = calculateCenter;
	  factory.calculateArea = calculateArea;

	  return factory;
	};

	exports.default = Parallelogram;

/***/ })
/******/ ]);